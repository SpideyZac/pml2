/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@sanity/diff-match-patch@3.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t) {
    const [n, e] = t;
    return [n, e];
}
function n(t, n) {
    let e = t,
        r = n;
    const l = e.length,
        s = r.length;
    if (0 === l || 0 === s) return 0;
    l > s ? (e = e.substring(l - s)) : l < s && (r = r.substring(0, l));
    const h = Math.min(l, s);
    if (e === r) return h;
    let i = 0,
        f = 1;
    for (let t = 0; -1 !== t; ) {
        const n = e.substring(h - f);
        if (((t = r.indexOf(n)), -1 === t)) return i;
        ((f += t),
            (0 === t || e.substring(h - f) === r.substring(0, f)) &&
                ((i = f), f++));
    }
    return i;
}
function e(t, n) {
    if (!t || !n || t[0] !== n[0]) return 0;
    let e = 0,
        r = Math.min(t.length, n.length),
        l = r,
        s = 0;
    for (; e < l; )
        (t.substring(s, l) === n.substring(s, l) ? ((e = l), (s = e)) : (r = l),
            (l = Math.floor((r - e) / 2 + e)));
    return l;
}
function r(t, n) {
    if (!t || !n || t[t.length - 1] !== n[n.length - 1]) return 0;
    let e = 0,
        r = Math.min(t.length, n.length),
        l = r,
        s = 0;
    for (; e < l; )
        (t.substring(t.length - l, t.length - s) ===
        n.substring(n.length - l, n.length - s)
            ? ((e = l), (s = e))
            : (r = l),
            (l = Math.floor((r - e) / 2 + e)));
    return l;
}
function l(t) {
    const n = t.charCodeAt(0);
    return n >= 55296 && n <= 56319;
}
function s(t) {
    const n = t.charCodeAt(0);
    return n >= 56320 && n <= 57343;
}
function h(t, n, e, r, l) {
    const s = t.substring(0, e),
        h = n.substring(0, r),
        i = t.substring(e),
        f = n.substring(r),
        g = L(s, h, { checkLines: !1, deadline: l }),
        o = L(i, f, { checkLines: !1, deadline: l });
    return g.concat(o);
}
function i(t, n, l) {
    const s = t.slice(l, l + Math.floor(t.length / 4));
    let h,
        i,
        f,
        g,
        o = -1,
        u = "";
    for (; -1 !== (o = n.indexOf(s, o + 1)); ) {
        const s = e(t.slice(l), n.slice(o)),
            c = r(t.slice(0, l), n.slice(0, o));
        u.length < c + s &&
            ((u = n.slice(o - c, o) + n.slice(o, o + s)),
            (h = t.slice(0, l - c)),
            (i = t.slice(l + s)),
            (f = n.slice(0, o - c)),
            (g = n.slice(o + s)));
    }
    return 2 * u.length >= t.length
        ? [h || "", i || "", f || "", g || "", u || ""]
        : null;
}
function f(t, n, e) {
    let r = t,
        l = n;
    const s = (function (t, n) {
        const e = [],
            r = {};
        function l(t) {
            let n = "",
                l = 0,
                h = -1,
                i = e.length;
            for (; h < t.length - 1; ) {
                ((h = t.indexOf("\n", l)), -1 === h && (h = t.length - 1));
                let f = t.slice(l, h + 1);
                ((r.hasOwnProperty ? r.hasOwnProperty(f) : void 0 !== r[f])
                    ? (n += String.fromCharCode(r[f]))
                    : (i === s && ((f = t.slice(l)), (h = t.length)),
                      (n += String.fromCharCode(i)),
                      (r[f] = i),
                      (e[i++] = f)),
                    (l = h + 1));
            }
            return n;
        }
        e[0] = "";
        let s = 4e4;
        const h = l(t);
        return ((s = 65535), { chars1: h, chars2: l(n), lineArray: e });
    })(r, l);
    ((r = s.chars1), (l = s.chars2));
    const h = s.lineArray;
    let i = L(r, l, { checkLines: !1, deadline: e.deadline });
    ((function (t, n) {
        for (let e = 0; e < t.length; e++) {
            const r = t[e][1],
                l = [];
            for (let t = 0; t < r.length; t++) l[t] = n[r.charCodeAt(t)];
            t[e][1] = l.join("");
        }
    })(i, h),
        (i = S(i)),
        i.push([w, ""]));
    let f = 0,
        g = 0,
        o = 0,
        u = "",
        c = "";
    for (; f < i.length; ) {
        switch (i[f][0]) {
            case p:
                (o++, (c += i[f][1]));
                break;
            case d:
                (g++, (u += i[f][1]));
                break;
            case w:
                if (g >= 1 && o >= 1) {
                    (i.splice(f - g - o, g + o), (f = f - g - o));
                    const t = L(u, c, { checkLines: !1, deadline: e.deadline });
                    for (let n = t.length - 1; n >= 0; n--)
                        i.splice(f, 0, t[n]);
                    f += t.length;
                }
                ((o = 0), (g = 0), (u = ""), (c = ""));
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
        f++;
    }
    return (i.pop(), i);
}
function g(t, n, e) {
    let r;
    if (!t) return [[p, n]];
    if (!n) return [[d, t]];
    const l = t.length > n.length ? t : n,
        s = t.length > n.length ? n : t,
        g = l.indexOf(s);
    if (-1 !== g)
        return (
            (r = [
                [p, l.substring(0, g)],
                [w, s],
                [p, l.substring(g + s.length)],
            ]),
            t.length > n.length && ((r[0][0] = d), (r[2][0] = d)),
            r
        );
    if (1 === s.length)
        return [
            [d, t],
            [p, n],
        ];
    const o = (function (t, n, e = 1) {
        if (e <= 0) return null;
        const r = t.length > n.length ? t : n,
            l = t.length > n.length ? n : t;
        if (r.length < 4 || 2 * l.length < r.length) return null;
        const s = i(r, l, Math.ceil(r.length / 4)),
            h = i(r, l, Math.ceil(r.length / 2));
        let f, g, o, u, c;
        if (s && h) f = s[4].length > h[4].length ? s : h;
        else {
            if (!s && !h) return null;
            h ? s || (f = h) : (f = s);
        }
        if (!f) throw new Error("Unable to find a half match.");
        return (
            t.length > n.length
                ? ((g = f[0]), (o = f[1]), (u = f[2]), (c = f[3]))
                : ((u = f[0]), (c = f[1]), (g = f[2]), (o = f[3])),
            [g, o, u, c, f[4]]
        );
    })(t, n);
    if (o) {
        const t = o[0],
            n = o[1],
            r = o[2],
            l = o[3],
            s = o[4],
            h = L(t, r, e),
            i = L(n, l, e);
        return h.concat([[w, s]], i);
    }
    return e.checkLines && t.length > 100 && n.length > 100
        ? f(t, n, e)
        : (function (t, n, e) {
              const r = t.length,
                  l = n.length,
                  s = Math.ceil((r + l) / 2),
                  i = s,
                  f = 2 * s,
                  g = new Array(f),
                  o = new Array(f);
              for (let t = 0; t < f; t++) ((g[t] = -1), (o[t] = -1));
              ((g[i + 1] = 0), (o[i + 1] = 0));
              const u = r - l,
                  c = u % 2 != 0;
              let a = 0,
                  b = 0,
                  w = 0,
                  m = 0;
              for (let d = 0; d < s && !(Date.now() > e); d++) {
                  for (let s = -d + a; s <= d - b; s += 2) {
                      const p = i + s;
                      let w;
                      w =
                          s === -d || (s !== d && g[p - 1] < g[p + 1])
                              ? g[p + 1]
                              : g[p - 1] + 1;
                      let m = w - s;
                      for (; w < r && m < l && t.charAt(w) === n.charAt(m); )
                          (w++, m++);
                      if (((g[p] = w), w > r)) b += 2;
                      else if (m > l) a += 2;
                      else if (c) {
                          const l = i + u - s;
                          if (l >= 0 && l < f && -1 !== o[l] && w >= r - o[l])
                              return h(t, n, w, m, e);
                      }
                  }
                  for (let s = -d + w; s <= d - m; s += 2) {
                      const a = i + s;
                      let b;
                      b =
                          s === -d || (s !== d && o[a - 1] < o[a + 1])
                              ? o[a + 1]
                              : o[a - 1] + 1;
                      let p = b - s;
                      for (
                          ;
                          b < r &&
                          p < l &&
                          t.charAt(r - b - 1) === n.charAt(l - p - 1);

                      )
                          (b++, p++);
                      if (((o[a] = b), b > r)) m += 2;
                      else if (p > l) w += 2;
                      else if (!c) {
                          const l = i + u - s;
                          if (l >= 0 && l < f && -1 !== g[l]) {
                              const s = g[l];
                              if (((b = r - b), s >= b))
                                  return h(t, n, s, i + s - l, e);
                          }
                      }
                  }
              }
              return [
                  [d, t],
                  [p, n],
              ];
          })(t, n, e.deadline);
}
var o = Object.defineProperty,
    u = Object.getOwnPropertySymbols,
    c = Object.prototype.hasOwnProperty,
    a = Object.prototype.propertyIsEnumerable,
    b = (t, n, e) =>
        n in t
            ? o(t, n, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: e,
              })
            : (t[n] = e);
const d = -1,
    p = 1,
    w = 0;
function m(t, n, e) {
    if (null === t || null === n) throw new Error("Null input. (diff)");
    const r = L(
        t,
        n,
        (function (t) {
            return ((t, n) => {
                for (var e in n || (n = {})) c.call(n, e) && b(t, e, n[e]);
                if (u) for (var e of u(n)) a.call(n, e) && b(t, e, n[e]);
                return t;
            })({ checkLines: !0, deadline: y(t.timeout || 1) }, t);
        })(e || {})
    );
    return (
        (function (t) {
            for (let n = 0; n < t.length; n++) {
                const [e, r] = t[n];
                if (0 === r.length) continue;
                const h = r[0];
                (l(r[r.length - 1]) && e === w && O(t, n, 1),
                    s(h) && e === w && O(t, n, -1));
            }
            for (let n = 0; n < t.length; n++)
                0 === t[n][1].length && t.splice(n, 1);
        })(r),
        r
    );
}
function L(t, n, l) {
    let s = t,
        h = n;
    if (s === h) return s ? [[w, s]] : [];
    let i = e(s, h);
    const f = s.substring(0, i);
    ((s = s.substring(i)), (h = h.substring(i)), (i = r(s, h)));
    const o = s.substring(s.length - i);
    ((s = s.substring(0, s.length - i)), (h = h.substring(0, h.length - i)));
    let u = g(s, h, l);
    return (f && u.unshift([w, f]), o && u.push([w, o]), (u = $(u)), u);
}
function y(t) {
    let n = 1;
    return (
        typeof t < "u" && (n = t <= 0 ? Number.MAX_VALUE : t),
        Date.now() + 1e3 * n
    );
}
function k(t, n, e) {
    return 1 === e ? t + n : n + t;
}
function A(t, n) {
    return 1 === n
        ? [t.substring(0, t.length - 1), t[t.length - 1]]
        : [t.substring(1), t[0]];
}
function O(t, n, e) {
    const r = 1 === e ? -1 : 1;
    let l = null,
        s = null,
        h = n + e;
    for (; h >= 0 && h < t.length && (null === l || null === s); h += e) {
        const [i, f] = t[h];
        if (0 !== f.length) {
            if (i === p) {
                null === l && (l = h);
                continue;
            }
            if (i === d) {
                null === s && (s = h);
                continue;
            }
            if (i === w) {
                if (null === l && null === s) {
                    const [l, s] = A(t[n][1], e);
                    return ((t[n][1] = l), void (t[h][1] = k(t[h][1], s, r)));
                }
                break;
            }
        }
    }
    if (
        null !== l &&
        null !== s &&
        (function (t, n, e, r) {
            return 1 === r
                ? t[n][1][t[n][1].length - 1] === t[e][1][t[e][1].length - 1]
                : t[n][1][0] === t[e][1][0];
        })(t, l, s, e)
    ) {
        const [h, i] = A(t[l][1], r),
            [f] = A(t[s][1], r);
        return (
            (t[l][1] = h),
            (t[s][1] = f),
            void (t[n][1] = k(t[n][1], i, e))
        );
    }
    const [i, f] = A(t[n][1], e);
    ((t[n][1] = i),
        null === l
            ? (t.splice(h, 0, [p, f]), null !== s && s >= h && s++)
            : (t[l][1] = k(t[l][1], f, r)),
        null === s ? t.splice(h, 0, [d, f]) : (t[s][1] = k(t[s][1], f, r)));
}
function S(e) {
    let r = e.map((n) => t(n)),
        l = !1;
    const s = [];
    let h = 0,
        i = null,
        f = 0,
        g = 0,
        o = 0,
        u = 0,
        c = 0;
    for (; f < r.length; )
        (r[f][0] === w
            ? ((s[h++] = f), (g = u), (o = c), (u = 0), (c = 0), (i = r[f][1]))
            : (r[f][0] === p ? (u += r[f][1].length) : (c += r[f][1].length),
              i &&
                  i.length <= Math.max(g, o) &&
                  i.length <= Math.max(u, c) &&
                  (r.splice(s[h - 1], 0, [d, i]),
                  (r[s[h - 1] + 1][0] = p),
                  h--,
                  h--,
                  (f = h > 0 ? s[h - 1] : -1),
                  (g = 0),
                  (o = 0),
                  (u = 0),
                  (c = 0),
                  (i = null),
                  (l = !0))),
            f++);
    for (l && (r = $(r)), r = v(r), f = 1; f < r.length; ) {
        if (r[f - 1][0] === d && r[f][0] === p) {
            const t = r[f - 1][1],
                e = r[f][1],
                l = n(t, e),
                s = n(e, t);
            (l >= s
                ? (l >= t.length / 2 || l >= e.length / 2) &&
                  (r.splice(f, 0, [w, e.substring(0, l)]),
                  (r[f - 1][1] = t.substring(0, t.length - l)),
                  (r[f + 1][1] = e.substring(l)),
                  f++)
                : (s >= t.length / 2 || s >= e.length / 2) &&
                  (r.splice(f, 0, [w, t.substring(0, s)]),
                  (r[f - 1][0] = p),
                  (r[f - 1][1] = e.substring(0, e.length - s)),
                  (r[f + 1][0] = d),
                  (r[f + 1][1] = t.substring(s)),
                  f++),
                f++);
        }
        f++;
    }
    return r;
}
const E = /[^a-zA-Z0-9]/,
    M = /\s/,
    x = /[\r\n]/,
    P = /\n\r?\n$/,
    j = /^\r?\n\r?\n/;
function v(n) {
    const e = n.map((n) => t(n));
    function l(t, n) {
        if (!t || !n) return 6;
        const e = t.charAt(t.length - 1),
            r = n.charAt(0),
            l = e.match(E),
            s = r.match(E),
            h = l && e.match(M),
            i = s && r.match(M),
            f = h && e.match(x),
            g = i && r.match(x),
            o = f && t.match(P),
            u = g && n.match(j);
        return o || u
            ? 5
            : f || g
              ? 4
              : l && !h && i
                ? 3
                : h || i
                  ? 2
                  : l || s
                    ? 1
                    : 0;
    }
    let s = 1;
    for (; s < e.length - 1; ) {
        if (e[s - 1][0] === w && e[s + 1][0] === w) {
            let t = e[s - 1][1],
                n = e[s][1],
                h = e[s + 1][1];
            const i = r(t, n);
            if (i) {
                const e = n.substring(n.length - i);
                ((t = t.substring(0, t.length - i)),
                    (n = e + n.substring(0, n.length - i)),
                    (h = e + h));
            }
            let f = t,
                g = n,
                o = h,
                u = l(t, n) + l(n, h);
            for (; n.charAt(0) === h.charAt(0); ) {
                ((t += n.charAt(0)),
                    (n = n.substring(1) + h.charAt(0)),
                    (h = h.substring(1)));
                const e = l(t, n) + l(n, h);
                e >= u && ((u = e), (f = t), (g = n), (o = h));
            }
            e[s - 1][1] !== f &&
                (f ? (e[s - 1][1] = f) : (e.splice(s - 1, 1), s--),
                (e[s][1] = g),
                o ? (e[s + 1][1] = o) : (e.splice(s + 1, 1), s--));
        }
        s++;
    }
    return e;
}
function $(n) {
    let l = n.map((n) => t(n));
    l.push([w, ""]);
    let s,
        h = 0,
        i = 0,
        f = 0,
        g = "",
        o = "";
    for (; h < l.length; )
        switch (l[h][0]) {
            case p:
                (f++, (o += l[h][1]), h++);
                break;
            case d:
                (i++, (g += l[h][1]), h++);
                break;
            case w:
                (i + f > 1
                    ? (0 !== i &&
                          0 !== f &&
                          ((s = e(o, g)),
                          0 !== s &&
                              (h - i - f > 0 && l[h - i - f - 1][0] === w
                                  ? (l[h - i - f - 1][1] += o.substring(0, s))
                                  : (l.splice(0, 0, [w, o.substring(0, s)]),
                                    h++),
                              (o = o.substring(s)),
                              (g = g.substring(s))),
                          (s = r(o, g)),
                          0 !== s &&
                              ((l[h][1] = o.substring(o.length - s) + l[h][1]),
                              (o = o.substring(0, o.length - s)),
                              (g = g.substring(0, g.length - s)))),
                      (h -= i + f),
                      l.splice(h, i + f),
                      g.length && (l.splice(h, 0, [d, g]), h++),
                      o.length && (l.splice(h, 0, [p, o]), h++),
                      h++)
                    : 0 !== h && l[h - 1][0] === w
                      ? ((l[h - 1][1] += l[h][1]), l.splice(h, 1))
                      : h++,
                    (f = 0),
                    (i = 0),
                    (g = ""),
                    (o = ""));
                break;
            default:
                throw new Error("Unknown diff operation");
        }
    "" === l[l.length - 1][1] && l.pop();
    let u = !1;
    for (h = 1; h < l.length - 1; )
        (l[h - 1][0] === w &&
            l[h + 1][0] === w &&
            (l[h][1].substring(l[h][1].length - l[h - 1][1].length) ===
            l[h - 1][1]
                ? ((l[h][1] =
                      l[h - 1][1] +
                      l[h][1].substring(
                          0,
                          l[h][1].length - l[h - 1][1].length
                      )),
                  (l[h + 1][1] = l[h - 1][1] + l[h + 1][1]),
                  l.splice(h - 1, 1),
                  (u = !0))
                : l[h][1].substring(0, l[h + 1][1].length) === l[h + 1][1] &&
                  ((l[h - 1][1] += l[h + 1][1]),
                  (l[h][1] =
                      l[h][1].substring(l[h + 1][1].length) + l[h + 1][1]),
                  l.splice(h + 1, 1),
                  (u = !0))),
            h++);
    return (u && (l = $(l)), l);
}
function I(...t) {
    return t.reduce((t, n) => t + (n ? 1 : 0), 0);
}
function U(n, e = 4) {
    let r = n.map((n) => t(n)),
        l = !1;
    const s = [];
    let h = 0,
        i = null,
        f = 0,
        g = !1,
        o = !1,
        u = !1,
        c = !1;
    for (; f < r.length; )
        (r[f][0] === w
            ? (r[f][1].length < e && (u || c)
                  ? ((s[h++] = f), (g = u), (o = c), (i = r[f][1]))
                  : ((h = 0), (i = null)),
              (u = !1),
              (c = !1))
            : (r[f][0] === d ? (c = !0) : (u = !0),
              i &&
                  ((g && o && u && c) ||
                      (i.length < e / 2 && 3 === I(g, o, u, c))) &&
                  (r.splice(s[h - 1], 0, [d, i]),
                  (r[s[h - 1] + 1][0] = p),
                  h--,
                  (i = null),
                  g && o
                      ? ((u = !0), (c = !0), (h = 0))
                      : (h--, (f = h > 0 ? s[h - 1] : -1), (u = !1), (c = !1)),
                  (l = !0))),
            f++);
    return (l && (r = $(r)), r);
}
var C = Object.defineProperty,
    D = Object.getOwnPropertySymbols,
    N = Object.prototype.hasOwnProperty,
    F = Object.prototype.propertyIsEnumerable,
    R = (t, n, e) =>
        n in t
            ? C(t, n, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: e,
              })
            : (t[n] = e),
    z = (t, n) => {
        for (var e in n || (n = {})) N.call(n, e) && R(t, e, n[e]);
        if (D) for (var e of D(n)) F.call(n, e) && R(t, e, n[e]);
        return t;
    };
const T = { threshold: 0.5, distance: 1e3 };
function V(t, n, e, r = {}) {
    if (n.length > 32) throw new Error("Pattern too long for this browser.");
    const l = (function (t) {
            return z(z({}, T), t);
        })(r),
        s = (function (t) {
            const n = {};
            for (let e = 0; e < t.length; e++) n[t.charAt(e)] = 0;
            for (let e = 0; e < t.length; e++)
                n[t.charAt(e)] |= 1 << (t.length - e - 1);
            return n;
        })(n);
    function h(t, r) {
        const s = t / n.length,
            h = Math.abs(e - r);
        return l.distance ? s + h / l.distance : h ? 1 : s;
    }
    let i = l.threshold,
        f = t.indexOf(n, e);
    -1 !== f &&
        ((i = Math.min(h(0, f), i)),
        (f = t.lastIndexOf(n, e + n.length)),
        -1 !== f && (i = Math.min(h(0, f), i)));
    const g = 1 << (n.length - 1);
    f = -1;
    let o,
        u,
        c = n.length + t.length,
        a = [];
    for (let r = 0; r < n.length; r++) {
        for (o = 0, u = c; o < u; )
            (h(r, e + u) <= i ? (o = u) : (c = u),
                (u = Math.floor((c - o) / 2 + o)));
        c = u;
        let l = Math.max(1, e - u + 1);
        const b = Math.min(e + u, t.length) + n.length,
            d = new Array(b + 2);
        d[b + 1] = (1 << r) - 1;
        for (let n = b; n >= l; n--) {
            const o = s[t.charAt(n - 1)];
            if (
                ((d[n] =
                    0 === r
                        ? ((d[n + 1] << 1) | 1) & o
                        : (((d[n + 1] << 1) | 1) & o) |
                          ((a[n + 1] | a[n]) << 1) |
                          1 |
                          a[n + 1]),
                d[n] & g)
            ) {
                const t = h(r, n - 1);
                if (t <= i) {
                    if (((i = t), (f = n - 1), !(f > e))) break;
                    l = Math.max(1, 2 * e - f);
                }
            }
        }
        if (h(r + 1, e) > i) break;
        a = d;
    }
    return f;
}
function X(t, n, e, r = {}) {
    if (null === t || null === n || null === e)
        throw new Error("Null input. (match())");
    const l = Math.max(0, Math.min(e, t.length));
    return t === n
        ? 0
        : t.length
          ? t.substring(l, l + n.length) === n
              ? l
              : V(t, n, l, r)
          : -1;
}
function Z(t) {
    const n = [];
    for (let e = 0; e < t.length; e++) t[e][0] !== p && (n[e] = t[e][1]);
    return n.join("");
}
function _(t) {
    const n = [];
    for (let e = 0; e < t.length; e++) t[e][0] !== d && (n[e] = t[e][1]);
    return n.join("");
}
function q(t) {
    let n = 0,
        e = 0,
        r = 0;
    for (let l = 0; l < t.length; l++) {
        const s = t[l][0],
            h = t[l][1];
        switch (s) {
            case p:
                e += h.length;
                break;
            case d:
                r += h.length;
                break;
            case w:
                ((n += Math.max(e, r)), (e = 0), (r = 0));
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
    }
    return ((n += Math.max(e, r)), n);
}
function B(t, n) {
    let e,
        r = 0,
        l = 0,
        s = 0,
        h = 0;
    for (
        e = 0;
        e < t.length &&
        (t[e][0] !== p && (r += t[e][1].length),
        t[e][0] !== d && (l += t[e][1].length),
        !(r > n));
        e++
    )
        ((s = r), (h = l));
    return t.length !== e && t[e][0] === d ? h : h + (n - s);
}
function G(t) {
    let n = 0;
    for (let e = 0; e < t.length; e++) {
        const r = t.codePointAt(e);
        if (typeof r > "u") throw new Error("Failed to get codepoint");
        n += J(r);
    }
    return n;
}
function H(n, e, r = {}) {
    let l = 0,
        s = 0;
    function h(t) {
        for (; l < t; ) {
            const t = e.codePointAt(s);
            if (typeof t > "u") return s;
            ((l += J(t)), (s += t > 65535 ? 2 : 1));
        }
        if (!r.allowExceedingIndices && l !== t)
            throw new Error("Failed to determine byte offset");
        return s;
    }
    const i = [];
    for (const e of n)
        i.push({
            diffs: e.diffs.map((n) => t(n)),
            start1: h(e.start1),
            start2: h(e.start2),
            utf8Start1: e.utf8Start1,
            utf8Start2: e.utf8Start2,
            length1: e.length1,
            length2: e.length2,
            utf8Length1: e.utf8Length1,
            utf8Length2: e.utf8Length2,
        });
    return i;
}
function J(t) {
    return t <= 127 ? 1 : t <= 2047 ? 2 : t <= 65535 ? 3 : 4;
}
const K = 32;
function Q(t, n) {
    return {
        diffs: [],
        start1: t,
        start2: n,
        utf8Start1: t,
        utf8Start2: n,
        length1: 0,
        length2: 0,
        utf8Length1: 0,
        utf8Length2: 0,
    };
}
function W(t, n, e = {}) {
    if ("string" == typeof t)
        throw new Error(
            "Patches must be an array - pass the patch to `parsePatch()` first"
        );
    let r = n;
    if (0 === t.length) return [r, []];
    const l = H(t, r, { allowExceedingIndices: e.allowExceedingIndices }),
        s = e.margin || 4,
        h = e.deleteThreshold || 0.4,
        i = (function (t, n = 4) {
            const e = n;
            let r = "";
            for (let t = 1; t <= e; t++) r += String.fromCharCode(t);
            for (const n of t)
                ((n.start1 += e),
                    (n.start2 += e),
                    (n.utf8Start1 += e),
                    (n.utf8Start2 += e));
            let l = t[0],
                s = l.diffs;
            if (0 === s.length || s[0][0] !== w)
                (s.unshift([w, r]),
                    (l.start1 -= e),
                    (l.start2 -= e),
                    (l.utf8Start1 -= e),
                    (l.utf8Start2 -= e),
                    (l.length1 += e),
                    (l.length2 += e),
                    (l.utf8Length1 += e),
                    (l.utf8Length2 += e));
            else if (e > s[0][1].length) {
                const t = s[0][1].length,
                    n = e - t;
                ((s[0][1] = r.substring(t) + s[0][1]),
                    (l.start1 -= n),
                    (l.start2 -= n),
                    (l.utf8Start1 -= n),
                    (l.utf8Start2 -= n),
                    (l.length1 += n),
                    (l.length2 += n),
                    (l.utf8Length1 += n),
                    (l.utf8Length2 += n));
            }
            if (
                ((l = t[t.length - 1]),
                (s = l.diffs),
                0 === s.length || s[s.length - 1][0] !== w)
            )
                (s.push([w, r]),
                    (l.length1 += e),
                    (l.length2 += e),
                    (l.utf8Length1 += e),
                    (l.utf8Length2 += e));
            else if (e > s[s.length - 1][1].length) {
                const t = e - s[s.length - 1][1].length;
                ((s[s.length - 1][1] += r.substring(0, t)),
                    (l.length1 += t),
                    (l.length2 += t),
                    (l.utf8Length1 += t),
                    (l.utf8Length2 += t));
            }
            return r;
        })(l, s);
    ((r = i + r + i),
        (function (t, n = 4) {
            for (let e = 0; e < t.length; e++) {
                if (t[e].length1 <= 32) continue;
                const r = t[e];
                t.splice(e--, 1);
                let l = r.start1,
                    s = r.start2,
                    h = "";
                for (; 0 !== r.diffs.length; ) {
                    const i = Q(l - h.length, s - h.length);
                    let f = !0;
                    if ("" !== h) {
                        const t = G(h);
                        ((i.length1 = h.length),
                            (i.utf8Length1 = t),
                            (i.length2 = h.length),
                            (i.utf8Length2 = t),
                            i.diffs.push([w, h]));
                    }
                    for (; 0 !== r.diffs.length && i.length1 < 32 - n; ) {
                        const t = r.diffs[0][0];
                        let e = r.diffs[0][1],
                            h = G(e);
                        if (t === p) {
                            ((i.length2 += e.length),
                                (i.utf8Length2 += h),
                                (s += e.length));
                            const t = r.diffs.shift();
                            (t && i.diffs.push(t), (f = !1));
                        } else
                            t === d &&
                            1 === i.diffs.length &&
                            i.diffs[0][0] === w &&
                            e.length > 64
                                ? ((i.length1 += e.length),
                                  (i.utf8Length1 += h),
                                  (l += e.length),
                                  (f = !1),
                                  i.diffs.push([t, e]),
                                  r.diffs.shift())
                                : ((e = e.substring(0, 32 - i.length1 - n)),
                                  (h = G(e)),
                                  (i.length1 += e.length),
                                  (i.utf8Length1 += h),
                                  (l += e.length),
                                  t === w
                                      ? ((i.length2 += e.length),
                                        (i.utf8Length2 += h),
                                        (s += e.length))
                                      : (f = !1),
                                  i.diffs.push([t, e]),
                                  e === r.diffs[0][1]
                                      ? r.diffs.shift()
                                      : (r.diffs[0][1] =
                                            r.diffs[0][1].substring(e.length)));
                    }
                    ((h = _(i.diffs)), (h = h.substring(h.length - n)));
                    const g = Z(r.diffs).substring(0, n),
                        o = G(g);
                    ("" !== g &&
                        ((i.length1 += g.length),
                        (i.length2 += g.length),
                        (i.utf8Length1 += o),
                        (i.utf8Length2 += o),
                        0 !== i.diffs.length &&
                        i.diffs[i.diffs.length - 1][0] === w
                            ? (i.diffs[i.diffs.length - 1][1] += g)
                            : i.diffs.push([w, g])),
                        f || t.splice(++e, 0, i));
                }
            }
        })(l, s));
    let f = 0;
    const g = [];
    for (let t = 0; t < l.length; t++) {
        const n = l[t].start2 + f,
            e = Z(l[t].diffs);
        let s,
            i = -1;
        if (
            (e.length > K
                ? ((s = X(r, e.substring(0, K), n)),
                  -1 !== s &&
                      ((i = X(r, e.substring(e.length - K), n + e.length - K)),
                      (-1 === i || s >= i) && (s = -1)))
                : (s = X(r, e, n)),
            -1 === s)
        )
            ((g[t] = !1), (f -= l[t].length2 - l[t].length1));
        else {
            let o;
            if (
                ((g[t] = !0),
                (f = s - n),
                (o =
                    -1 === i
                        ? r.substring(s, s + e.length)
                        : r.substring(s, i + K)),
                e === o)
            )
                r =
                    r.substring(0, s) +
                    _(l[t].diffs) +
                    r.substring(s + e.length);
            else {
                let n = m(e, o, { checkLines: !1 });
                if (e.length > K && q(n) / e.length > h) g[t] = !1;
                else {
                    n = v(n);
                    let e = 0,
                        h = 0;
                    for (let i = 0; i < l[t].diffs.length; i++) {
                        const f = l[t].diffs[i];
                        (f[0] !== w && (h = B(n, e)),
                            f[0] === p
                                ? (r =
                                      r.substring(0, s + h) +
                                      f[1] +
                                      r.substring(s + h))
                                : f[0] === d &&
                                  (r =
                                      r.substring(0, s + h) +
                                      r.substring(s + B(n, e + f[1].length))),
                            f[0] !== d && (e += f[1].length));
                    }
                }
            }
        }
    }
    return ((r = r.substring(i.length, r.length - i.length)), [r, g]);
}
var Y = Object.defineProperty,
    tt = Object.getOwnPropertySymbols,
    nt = Object.prototype.hasOwnProperty,
    et = Object.prototype.propertyIsEnumerable,
    rt = (t, n, e) =>
        n in t
            ? Y(t, n, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: e,
              })
            : (t[n] = e),
    lt = (t, n) => {
        for (var e in n || (n = {})) nt.call(n, e) && rt(t, e, n[e]);
        if (tt) for (var e of tt(n)) et.call(n, e) && rt(t, e, n[e]);
        return t;
    };
const st = { margin: 4 };
function ht(t = {}) {
    return lt(lt({}, st), t);
}
function it(t, n, e) {
    if ("string" == typeof t && "string" == typeof n) {
        let r = m(t, n, { checkLines: !0 });
        return (r.length > 2 && ((r = S(r)), (r = U(r))), ft(t, r, ht(e)));
    }
    if (t && Array.isArray(t) && typeof n > "u") return ft(Z(t), t, ht(e));
    if ("string" == typeof t && n && Array.isArray(n)) return ft(t, n, ht(e));
    throw new Error("Unknown call format to make()");
}
function ft(t, n, e) {
    if (0 === n.length) return [];
    const r = [];
    let l = Q(0, 0),
        s = 0,
        h = 0,
        i = 0,
        f = 0,
        g = 0,
        o = t,
        u = t;
    for (let t = 0; t < n.length; t++) {
        const c = n[t],
            [a, b] = c,
            m = b.length,
            L = G(b);
        switch (
            (!s &&
                a !== w &&
                ((l.start1 = h),
                (l.start2 = i),
                (l.utf8Start1 = f),
                (l.utf8Start2 = g)),
            a)
        ) {
            case p:
                ((l.diffs[s++] = c),
                    (l.length2 += m),
                    (l.utf8Length2 += L),
                    (u = u.substring(0, i) + b + u.substring(i)));
                break;
            case d:
                ((l.length1 += m),
                    (l.utf8Length1 += L),
                    (l.diffs[s++] = c),
                    (u = u.substring(0, i) + u.substring(i + m)));
                break;
            case w:
                m <= 2 * e.margin && s && n.length !== t + 1
                    ? ((l.diffs[s++] = c),
                      (l.length1 += m),
                      (l.length2 += m),
                      (l.utf8Length1 += L),
                      (l.utf8Length2 += L))
                    : m >= 2 * e.margin &&
                      s &&
                      (gt(l, o, e),
                      r.push(l),
                      (l = Q(-1, -1)),
                      (s = 0),
                      (o = u),
                      (h = i),
                      (f = g));
                break;
            default:
                throw new Error("Unknown diff type");
        }
        (a !== p && ((h += m), (f += L)), a !== d && ((i += m), (g += L)));
    }
    return (s && (gt(l, o, e), r.push(l)), r);
}
function gt(t, n, e) {
    if (0 === n.length) return;
    let r = n.substring(t.start2, t.start2 + t.length1),
        l = 0;
    for (
        ;
        n.indexOf(r) !== n.lastIndexOf(r) && r.length < K - e.margin - e.margin;

    )
        ((l += e.margin),
            (r = n.substring(t.start2 - l, t.start2 + t.length1 + l)));
    l += e.margin;
    let h = t.start2 - l;
    h >= 1 && s(n[h]) && h--;
    const i = n.substring(h, t.start2);
    i && t.diffs.unshift([w, i]);
    const f = i.length,
        g = G(i);
    let o = t.start2 + t.length1 + l;
    o < n.length && s(n[o]) && o++;
    const u = n.substring(t.start2 + t.length1, o);
    u && t.diffs.push([w, u]);
    const c = u.length,
        a = G(u);
    ((t.start1 -= f),
        (t.start2 -= f),
        (t.utf8Start1 -= g),
        (t.utf8Start2 -= g),
        (t.length1 += f + c),
        (t.length2 += f + c),
        (t.utf8Length1 += g + a),
        (t.utf8Length2 += g + a));
}
const ot = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function ut(t) {
    if (!t) return [];
    const n = [],
        e = t.split("\n");
    let r = 0;
    for (; r < e.length; ) {
        const t = e[r].match(ot);
        if (!t) throw new Error(`Invalid patch string: ${e[r]}`);
        const l = Q(ct(t[1]), ct(t[3]));
        for (
            n.push(l),
                "" === t[2]
                    ? (l.start1--,
                      l.utf8Start1--,
                      (l.length1 = 1),
                      (l.utf8Length1 = 1))
                    : "0" === t[2]
                      ? ((l.length1 = 0), (l.utf8Length1 = 0))
                      : (l.start1--,
                        l.utf8Start1--,
                        (l.utf8Length1 = ct(t[2])),
                        (l.length1 = l.utf8Length1)),
                "" === t[4]
                    ? (l.start2--,
                      l.utf8Start2--,
                      (l.length2 = 1),
                      (l.utf8Length2 = 1))
                    : "0" === t[4]
                      ? ((l.length2 = 0), (l.utf8Length2 = 0))
                      : (l.start2--,
                        l.utf8Start2--,
                        (l.utf8Length2 = ct(t[4])),
                        (l.length2 = l.utf8Length2)),
                r++;
            r < e.length;

        ) {
            const t = e[r],
                n = t.charAt(0);
            if ("@" === n) break;
            if ("" === n) {
                r++;
                continue;
            }
            let s;
            try {
                s = decodeURI(t.slice(1));
            } catch (n) {
                throw new Error(`Illegal escape in parse: ${t}`);
            }
            const h = G(s) - s.length;
            if ("-" === n) (l.diffs.push([d, s]), (l.length1 -= h));
            else if ("+" === n) (l.diffs.push([p, s]), (l.length2 -= h));
            else {
                if (" " !== n)
                    throw new Error(`Invalid patch mode "${n}" in: ${s}`);
                (l.diffs.push([w, s]), (l.length1 -= h), (l.length2 -= h));
            }
            r++;
        }
    }
    return n;
}
function ct(t) {
    return parseInt(t, 10);
}
function at(t) {
    return t.map(bt).join("");
}
function bt(t) {
    const {
        utf8Length1: n,
        utf8Length2: e,
        utf8Start1: r,
        utf8Start2: l,
        diffs: s,
    } = t;
    let h, i;
    ((h = 0 === n ? `${r},0` : 1 === n ? `${r + 1}` : `${r + 1},${n}`),
        (i = 0 === e ? `${l},0` : 1 === e ? `${l + 1}` : `${l + 1},${e}`));
    const f = [`@@ -${h} +${i} @@\n`];
    let g;
    for (let t = 0; t < s.length; t++) {
        switch (s[t][0]) {
            case p:
                g = "+";
                break;
            case d:
                g = "-";
                break;
            case w:
                g = " ";
                break;
            default:
                throw new Error("Unknown patch operation.");
        }
        f[t + 1] = `${g + encodeURI(s[t][1])}\n`;
    }
    return f.join("").replace(/%20/g, " ");
}
export {
    d as DIFF_DELETE,
    w as DIFF_EQUAL,
    p as DIFF_INSERT,
    H as adjustIndiciesToUcs2,
    W as applyPatches,
    U as cleanupEfficiency,
    S as cleanupSemantic,
    m as makeDiff,
    it as makePatches,
    X as match,
    ut as parsePatch,
    bt as stringifyPatch,
    at as stringifyPatches,
    B as xIndex,
};
export default null;
//# sourceMappingURL=/sm/aee049a15daed64525597cc21f50e293f9ec5f46f6ad3296788b2b601977c647.map
